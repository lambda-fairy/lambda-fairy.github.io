<!DOCTYPE html><meta charset="utf-8"><title>Hackage update, part 4
 〜 lambda fairy</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Libre+Franklin:ital,wght@0,400;0,500;0,700;0,900;1,400;1,500;1,700"><link rel="stylesheet" href="/styles.css"><meta name="theme-color" content="#6b5391"><meta name="viewport" content="width=device-width"><header><h1><a href="/">lambda fairy</a><script>
                        const headerLink = document.currentScript.previousElementSibling;
                        headerLink.addEventListener('click', () => {
                            const bottom = window.getComputedStyle(headerLink).getPropertyValue('bottom');
                            headerLink.style.bottom = bottom;
                            sessionStorage.setItem('headerClicked', bottom);
                        });
                        const previousBottom = sessionStorage.getItem('headerClicked');
                        if (previousBottom) {
                            sessionStorage.removeItem('headerClicked');
                            headerLink.style.bottom = previousBottom;
                            headerLink.style.transition = 'none';
                            setTimeout(() => {
                                headerLink.style.bottom = '';
                                headerLink.style.transition = '';
                            });
                        }
                    </script></h1></header><main><h1>Hackage update, part 4</h1><p><small><time datetime="2014-08-30">August 30, 2014</time></small></p><p>A lot has happened with Hackage since my <a href="/blog/hackage-part-3/">last update</a>. Now that the Summer of Code is over, I’ll summarize the work I’ve done since then, and outline where this project will go next.</p>
<h2><a href="#whats-build-reporting" aria-hidden="true" class="anchor" id="whats-build-reporting"></a>What’s “build reporting”?</h2>
<p>Since my project covered a few obscure parts of Hackage and Cabal, I think it’s worthwhile to clear some terminology first.</p>
<p>If you’ve uploaded a library to <a href="https://hackage.haskell.org/">Hackage</a> before, you may have noticed that the Haddock documentation does not appear straight away. Since building a package can be quite resource intensive, the job is handled by a dedicated <em>build bot</em>. This bot continually polls for new packages, invokes <code>cabal install</code> on them (with some special flags, which I’ll go into later), and uploads the result.</p>
<p>Of course, this process does not always succeed. If a package fails to compile, then it will not have any documentation either. This is clearly very inconvenient.</p>
<p>Fortunately, recent versions of <code>cabal</code> include a feature called <em>build reporting</em>. When invoked with the <code>--build-summary</code> option, <code>cabal</code> creates a file containing useful information about the build. Here’s an example using the <code>robot</code> package:</p>
<pre>
<span style="color:#323232;">$ cabal install robot --build-summary=&#39;$pkg.report&#39;
</span><span style="color:#323232;">...
</span><span style="color:#323232;">$ cat robot.report
</span><span style="color:#323232;">package: robot-1.3.0.1
</span><span style="color:#323232;">os: linux
</span><span style="color:#323232;">arch: x86_64
</span><span style="color:#323232;">compiler: ghc-7.6.3
</span><span style="color:#323232;">client: cabal-install-1.20.0.3
</span><span style="color:#323232;">dependencies: xhb-0.5.2014.4.10 transformers-0.3.0.0
</span><span style="color:#323232;">              exceptions-0.6.1 containers-0.5.0.0 base-4.6.0.1
</span><span style="color:#323232;">install-outcome: InstallOk
</span><span style="color:#323232;">docs-outcome: NotTried
</span><span style="color:#323232;">tests-outcome: NotTried
</span></pre>
<p>Since the build bot uses <code>cabal</code>, it has access to these reports as well. So whenever the bot completes a build — successful or not — it posts the corresponding report to Hackage. You can read these reports yourself via a special URL; for our <code>robot</code> example it’s <a href="http://hackage.haskell.org/package/robot-1.3.0.1/reports/">http://hackage.haskell.org/package/robot-1.3.0.1/reports/</a>.</p>
<p>In summary: if the docs for a package are missing, then the reports will tell us why. If there are no reports, then it must mean the build bot hasn’t attempted the package yet. All is fine and dandy, at least in theory.</p>
<h2><a href="#unfortunately" aria-hidden="true" class="anchor" id="unfortunately"></a>Unfortunately…</h2>
<p>… not all builds were reported. The gaps were in two places: <em>planning failures</em> and <em>package candidates</em>. My <a href="https://github.com/haskell/cabal/pull/2025">latest patch</a> to <code>cabal</code> fixed both these issues.</p>
<h3><a href="#reporting-planning-failures" aria-hidden="true" class="anchor" id="reporting-planning-failures"></a>Reporting planning failures</h3>
<p>A <em>planning failure</em> is when cabal-install cannot find a consistent set of dependencies to use. You can trigger a planning failure yourself:</p>
<pre>
<span style="color:#323232;">$ cabal install robot --constraint=&#39;robot &lt; 1.1&#39; --constraint=&#39;robot &gt; 1.1&#39;
</span><span style="color:#323232;">cabal: Could not resolve dependencies:
</span><span style="color:#323232;">...
</span></pre>
<p>Since we can’t have a <code>robot</code> which is both older <em>and</em> newer than 1.1, the resolver fails.</p>
<p>Formerly, as dependency resolution ran early in the build process, any failures at this stage did not generate a corresponding report. So if the build bot encountered a planning failure, all the user saw was missing documentation, with no hints as to what went wrong.</p>
<p>The fix was mostly straightforward, save for one issue: since users can report their own builds, a naïve implementation would have lead to Hackage being swamped with frivolous reports. So this feature is guarded behind a flag (<code>--report-planning-failure</code>), and disabled by default.</p>
<h3><a href="#reporting-candidate-builds" aria-hidden="true" class="anchor" id="reporting-candidate-builds"></a>Reporting candidate builds</h3>
<p>Hackage has a feature called <em>build candidates</em>. This lets package maintainers upload and test packages without publishing them to the main site.</p>
<p>Again, the problem was the lack of reporting: when a candidate was uploaded, the build bot would compile the package but not submit a report. This was a major issue, since this reporting was what motivated the feature in the first place.</p>
<p>After some digging, I traced this to <a href="https://github.com/haskell/cabal/issues/1189">a bug in <code>cabal</code></a>. A candidate is not published in the main package index (by definition), so it is impossible to refer to one by name (e.g. <code>hello-1.0</code>). So the build bot invokes <code>cabal</code> using the bare URL instead (e.g. <code>http://hackage.haskell.org/package/hello/candidates/hello-1.0.tar.gz</code>).</p>
<p>The problem was if only a URL was given, <code>cabal</code> considered it a “local” package and did not generate a report. The reason for this behavior is outside the scope of this post, but the fix was clear: change <code>cabal</code> to generate reports for all packages, no matter how they are specified on the command line.</p>
<h2><a href="#where-to-next" aria-hidden="true" class="anchor" id="where-to-next"></a>Where to next?</h2>
<p>Though the Summer of Code has ended, my work with Hackage has not. There are still many issues that need clearing up, especially with the <a href="https://github.com/haskell/hackage-server/labels/component:%20candidates">candidates feature</a>; I’ll continue hacking away at them in my spare time.</p>
<p>And lest I forget — many thanks to my mentor Duncan Coutts for his guidance throughout this project! I had plenty of fun this summer, and learned just as much.</p>
</main><script>
                async function inlineSVG(imgElement) {
                    const altText = imgElement.alt;
                    const placeholder = document.createElement('div');
                    imgElement.replaceWith(placeholder);
                    try {
                        const text = await (await fetch(imgElement.src)).text();
                        const svgElement = new DOMParser().parseFromString(text, 'image/svg+xml').rootElement;
                        svgElement.removeAttribute('width');
                        svgElement.removeAttribute('height');
                        svgElement.prepend(createSVGTitle(altText));
                        placeholder.replaceWith(svgElement);
                    } catch (e) {
                        console.error(e);
                        placeholder.replaceWith(imgElement);
                    }
                }
                function createSVGTitle(text) {
                    const element = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                    element.textContent = text;
                    return element;
                }
                for (const imgElement of [...document.getElementsByTagName('img')]) {
                    const src = imgElement.src;
                    if (!src.endsWith('.svg')) continue;
                    if (new URL(src).host !== location.host) continue;
                    inlineSVG(imgElement);
                }
            </script>
<script src="//static.getclicky.com/js"></script><script>try{ clicky.init(100874553); }catch(e){}</script>
<noscript><p><img alt="" width="1" height="1" src="//in.getclicky.com/100874553ns.gif"></p></noscript>
